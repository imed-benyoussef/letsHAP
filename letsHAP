#!/usr/bin/env sh

##################################################
### letshap - David S. - 2016, 1st of October  ###
##################################################

###
### That program needs you to create a specific backend 
### in haproxy's configfile.
###
#var1="$1"
#var2="$2"
#var3="$3"

# Help
func_usage(){
cat << EOF

 ~ Usage : $0 [Options] [PARAM]

 Beware : First start, you have to run $0 --register [EMAIL]

Options
-------
-dry | --dry-run
* Simulate behavior. Have to be passed as first ARGV

-re | --register [EMAIL]
* Create /etc/letsencrypt directory after creating your account on let's Encrypt

-a  |--add [DOMAIN]
* Add certs files for the domain
* Create renewal config file for that domain
* Add and refresh HAProxy's ssl cert list
* HAProxy : Check config file && restart

-ra |--renew-all :
* Renew what's needed for renewed domains
* Regenerate .pem files for HAProxy
* HAProxy : Check config file && restart

-rev|--revoke [DOMAIN]
* to be coded if needed

...

EOF
}

# We need at least 1 argument
check_argv1_f(){
        if [[ ( "${var1}" == '') ]]
        then
		echo $var1
		echo "here we are"
                func_usage
		echo "Parameter's missing ; at least one is needed - exit"
                exit 1
        fi
}
# Check vars
#check_argv1_f


###############
### GLOBALS ###
###############
DATE=$(date +%Y%m%d-%H%M%S)
WORKING_DIR='/etc/letsencrypt'
HAPX_CONFFILE='/etc/haproxy/haproxy-base.conf'
HAPX_INSTANCE='haproxy@base' # use 'haproxy' if only one instance exists (like out of the box)
HAPX_CERTDIR='/etc/haproxy/ssl'
HAPX_CERTLIST='/etc/haproxy/ssl/ssl.lst'
LETS_LIVE_PATH='/etc/letsencrypt/live'
LETS_ARCH_PATH='/etc/letsencrypt/archive'
INSTALLED_DOMAINS="$(ls -d ${LETS_LIVE_PATH}/* | cut -d'/' -f 5)"
OUTPUT_RD="${WORKING_DIR}/renewal/autorenew_domains.${DATE}"
PREFERRED_CHALLENGE='http-01'
CERTBOT_BK_NAME="http-01-port"
BK_PORT='63443'

# Our cases of action

## Adding dry-run 
#case ${var3} in
#        -dry | --dry-run)
#                dryrun='--dry-run'
#                echo $dryrun
#                ;;
#        *)
                
#        	;;
#esac

for argv1 in "$@"
do
	case ${argv1} in
		-re | --register)
			todo='register'
			REGISTERING_EMAIL="$2"
			shift
			;;
		-a |--add)
			todo="add"
			domainToAdd="$2"
			shift
			;;
		-ra |--renew-all)
			todo="renew-all"
			shift
			;;
		-rev|--revoke)
			todo="revoke"
			domainToRevoke="$2"
			shift
			;;
		-dry | --dry-run)
			dryrun='--dry-run'
			shift
			;;
		-h| --help)
			func_usage
			;;
#		*)
#			func_usage
#			;;
	esac
done

#################
### FUNCTIONS ###
#################

_register(){
	email="${1}"
	if [[ -z "${REGISTERING_EMAIL}" ]] 
	then
		func_usage
		exit 1
	else
			certbot register --no-eff-email --agree-tos -m ${email}
	fi
}

_add_cert_for_domain (){
	myDomain="$1"
	# the magic
	echo -n "Let's create your cert for $myDomain... "
	echo "here we are"

	# --expand allow to add domains/SANs to an existing certificate
	# --allow-subset-of-names tells Certbot to continue with certificate generation if only some of the specified domain authorizations can be obtained. This may be useful if some domains specified in a certificate no longer point at this system.
	# the comma separated format for -d $domains is also supported by HAProxy ssl.lst
	create_cert=$(certbot certonly ${dryrun} --expand --standalone --preferred-challenges ${PREFERRED_CHALLENGE} --${CERTBOT_BK_NAME} ${BK_PORT} --noninteractive -d ${myDomain})
        is_success=$(echo $?)
        if [ "$is_success" = '0' ]
        then
                echo "OK"
		echo -n "Updating HAPROXY certlist... "
		
        else
                echo "NOK - exit"
		echo $create_cert
                exit 1
        fi

}

_create_haproxy_fullchain (){
	# Can be multiple domains comma separated
	domain="${1}"
	# autocertname will be the DIR name in let's ARCH and LIVE dirs
	autocertname=$(echo ${domain} | cut -d',' -f1)

	# Those might be global VARS...
	fullchainFileHAP="${LETS_ARCH_PATH}/${autocertname}/fullchain_haproxy.pem"
	fullchainFile="${LETS_LIVE_PATH}/${autocertname}/fullchain.pem"
	privkeyFile="${LETS_LIVE_PATH}/${autocertname}/privkey.pem"

	# Checking if that domain/autocertname's DIR exists
	if [ ! -d "${LETS_ARCH_PATH}/${autocertname}" ]
	then 
		echo "Domain(s) ${domain} has no certificate installed on this server - exit"
		exit 1
	fi
	# Overwrite HAP fullchain if exists (should not :])
	echo "Creating HAPROXY fullchain file for domain(s) ${domain}... "
        cat "${fullchainFile}" "${privkeyFile}" > ${fullchainFileHAP} && echo -n "OK " || echo -n "NOK - "
        echo

	# Symlink the new fullchain file in let's live dir
	echo -n "Creating symlink in live directory... "
	if [ ! \(-L ${fullchainFileHAP} \) ] 
	then
		ln -s ${fullchainFileHAP} ${LETS_LIVE_PATH}/${autocertname}/ && echo OK || echo NOK
	else
		echo 'No need'
	fi

	# Feeding HAProxy ssl.lst
	echo -n "Adding line(s) in ${HAPX_CERTLIST}... "
	sed -i "/${autocertname}/d" "${HAPX_CERTLIST}"
	echo "${LETS_LIVE_PATH}/${autocertname}/fullchain_haproxy.pem ${domain}" >> ${HAPX_CERTLIST} && echo OK || echo NOK

	# We restart haproxy for instant production use of the domain
	_restart_haproxy "${HAPX_CONFFILE}" "${HAPX_INSTANCE}"
}

_renew_domains(){
	echo "**** Renewing all domains **** "
	renew=$(certbot renew ${dryrun} --standalone --preferred-challenges ${PREFERRED_CHALLENGE} --${CERTBOT_BK_NAME} ${BK_PORT})
	is_success=$(echo $?)
	if [ "$is_success" = '0' ]
	then
		echo "$renew" > ${OUTPUT_RD}
		echo "OK" 
	else
		echo "NOK - exit"
		exit 1
	fi

}

_restart_haproxy (){
	conffile="$1"
	instance="${2}"
	check_conf=$(/usr/sbin/haproxy -f ${conffile} -c)
	is_success=$(echo $?)
	if [ $is_success -eq '0' ]
	then
		echo -n "Restarting haproxy (stop & start)... "
		systemctl stop ${instance}.service || echo -n "(Problem while stopping ${instance}.service)... "
		systemctl start ${instance}.service && echo OK || echo NOK
	else
		echo "Problem with HAPROXY config file - exit"
		exit 1
	fi
}

_update_haproxy_fullchains (){
	myOutputFile="$1"
        fullchainFileHAP="${LETS_ARCH_PATH}/${certname}/fullchain_haproxy.pem"
        fullchainFile="${LETS_LIVE_PATH}/${certname}/fullchain.pem"
        privkeyFile="${LETS_LIVE_PATH}/${certname}/privkey.pem"

	fullchainsToRenew=$( cat ${myOutputFile} | grep letsencrypt | grep success | awk '{print $1}')
	if [ "$fullchainsToRenew" != '' ]
	then
		echo "*** Renewing fullchains for HAPROXY ***"
		for cert in $fullchainsToRenew
		do
			echo "Fullchain to renew -> $cert"
			certname=$(echo $cert | cut -d'/' -f 5)
			# Backup the old fullchain file and freeing the file
			echo -n "Backup the old fullchain file of $domain : "
			if [ -f "${fullchainFileHAP}" ]
			then
				mv ${fullchainFileHAP} ${fullchainFileHAP}.${DATE} && echo OK || echo NOK
			else
				echo "doesn't exist - next"
			fi

			# generate the new one
			echo "Generating the new one... "
			for file in ${fullchainFile} ${privkeyFile} 
			do
				echo -n "cat $file : "
				cat ${file} >> ${fullchainFileHAP} && echo -n "OK " || echo -n "NOK - "
				echo
			done
		done

		# We need to restart HAPROXY, of course
		_restart_haproxy "${HAPX_CONFFILE}" "${HAPX_INSTANCE}"

	else
		echo "Nothing to update - exit"
		exit 0
	fi
}

################
#### ACTION ####
################

# Create HAProxy ssl list file DIR
if [[ ! -d "${HAPX_CERTDIR}" ]]
then
	read -p "Do you want to create ${HAPX_CERTDIR} ? [Y/n]" yn
	yn=${yn:Y}
	case $yn in
        	[Yy]* ) 
			mkdir -p ${HAPX_CERTDIR} 
			;;

	        [Nn]* ) 
			exit 
			;;

 	       * ) 
		      	echo " ~~ 0_o ~~ " 
			exit
			;;
	esac
fi
	
        case $todo in
		register)
			_register ${REGISTERING_EMAIL}
			;;
                add)
                	_add_cert_for_domain ${domainToAdd}
			_create_haproxy_fullchain ${domainToAdd}
                ;;

                renew-all)
			_renew_domains
                        _update_haproxy_fullchains $OUTPUT_RD
                ;;

                revoke)
                        echo "Function revoke haven't been coded yet"
                ;;
                *)
                        func_usage
                ;;
        esac

